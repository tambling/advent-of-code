c
quit
value
quit
compressed_string
compression.each do |value,key| compressed_string.gsub!(value,key) end
new_string
new_string.gsub! 'foo', 'f'
new_string = 'foob'
compressed_string
compression.each do |value,key| compressed_string = compressed_string.gsub(value,key) end
compressed_string
string
compression.each do |value,key| string = string.gsub(value,key) end
string
string.gsub compression.values.last, 'c'
compression.each do |value, key| puts key, value end
compression.values.first
string
compression.each do |value,key| string.gsub!(value,key) end
string
compression.each do |value,key| string.gsub(value,key) end
compression.each_with_index do |value,key| string.gsub(value,key) end
compression.each_with_index do |value| string.gsub(value,key) end
string
compression
quit
compression
string
quit
find_repeated_sequence string, 5
find_repeated_sequence string, 4
expanded_sequence
string
compression
quit
compression
compressed_string
c
q
compression
compressed_string
c
quit
compressed_string
c
quit
compressed_string
compression
c
quit
string
c
quit
compressed_string
compression
c
quit
65.chr
70.chr
74.chr
90.chr
101.chr
1.chr
string.gsub(string[0..i - 1], 'a')
string.gsub(string[0..i - 1])
string
expanded_sequence
_.length
string[0..i - 1]
i
q
c
y - 1 >= 0
x - 1 >= 0
@points.first.length
@points.length
quit
string.match /(.+)\1+/
string[-1]
string.length
string.size
unrepeat string
string = patterns.last(3).first
patterns.last(3).first
patterns.last(3)
patterns.map { |pattern| unrepeat(pattern) }
patterns = patterns_by_digit all_rounds
all_rounds = fft_repeat inputs.first, 200
quit
  end
     end
        return i + 1
     if newstr == str
     newstr = newstr[-1] + newstr[0..-2]
  n.times do |i|
  newstr = str
  n = str.size
def unrepeat(str)
[1, 2, 3].index(2, 3)
[1, 2, 3].index([2, 3])
patterns.map { |pattern| cycle_length(pattern) }
patterns = patterns_by_digit all_rounds
all_rounds = fft_repeat inputs.first, 200
quit
patterns.map { |pattern| cycle_length(pattern) }
patterns = patterns_by_digit all_rounds
all_rounds = fft_repeat inputs.first, 200
quit
patterns = (0..all_rounds.last.length).map do |index| all_rounds.map { |round| round[index]}.join end
all_rounds = fft_repeat(inputs.first * 2, 100)
all_rounds = fft_repeat(inputs.first, 100)
c
quit
patterns[-2].split('').each_slice(6).uniq
patterns[-2].split('').each_slice(5).uniq
patterns[-2].split('').each_slice(4).uniq
patterns[-2].split('').each_slice(3).uniq
patterns[-2].split('').each_slice(2).uniq
patterns[-2].split('').each_slice(1).uniq
patterns.last.split('').each_slice(1).uniq
patterns.last.each_slice(1).uniq
patterns.pop
patterns = (0..8).map do |index| all_rounds.map { |round| round[index]}.join end
(0..8).map do |index| all_rounds.map { |round| round[index]}.join end
(0..8).map do |index| all_rounds.map { |round| round[index]}.join }
all_rounds.length
all_rounds
flawed_frequency_transmission input
input = inputs.first * 10000
input
quit
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
c
multiplier
raw_input
i
quit
@visit.previous
c
[nil, nil, nil].select(&:even?)
[nil, nil, nil].compact
@visit.bfs_levels_to_oxygen
@vist.bfs_levels_to_oxygen
quit
@visit.bfs_levels_to_oxygen
quit
@visit
quit
@visit[:north]
@visit[:south]
c
@visit[:east]
@visit[:south].unvisited?
@visit[:south]
continue
@visit
c
@visit
quit
@visits.map(&:unvisited_neighbors?)
@visits.map(&:unvisited_neighbors)
@visits.map(&:unvisited_neighbors
@visits
evaluate_surroundings
c
quit
go @visit.next_unvisited_direction
go :south
evaluate_surroundings
go :north
@visit.next_unvisited_direction
@visit.previous_direction
evaluate_surroundings
go :south
@visit.next_unvisited_direction
@visit.add_unvisited :south
direction
@visit
@location
c
@location
c
@location
c
quit
@visits.first
c
quit
c
@visit
evaluate_surroundings
go :south
@visit.next_unvisited_direction
@visit.next_unvisited
@visit
quit
@visits.first[:south]
@visits.first
@visits
quit
@map
quit
c
quit
@direction
relative_coordinates @direction
@location
c
quit
@visit
c
s
step
send_direction direction
direction
starting_location = @location.clone
@location
quit
go :north
 go :north
@location
@brain.inputs
